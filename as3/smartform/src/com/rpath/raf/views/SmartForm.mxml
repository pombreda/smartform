<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (c) 2009-2011 rPath, Inc.

This program is distributed under the terms of the MIT License as found 
in a file called LICENSE. If it is not present, the license
is always available at http://www.opensource.org/licenses/mit-license.php.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of merchantability
or fitness for a particular purpose. See the MIT License for full details.
-->


<mx:Form 
    xmlns:fx="http://ns.adobe.com/mxml/2009" 
    xmlns:s="library://ns.adobe.com/flex/spark" 
    xmlns:mx="library://ns.adobe.com/flex/mx" 
    
    creationComplete="onCreationComplete(event)"
    
    implements="com.rpath.raf.util.IValidationAware"
    backgroundAlpha="0"
    paddingTop="0"
    >
    
    <fx:Metadata>
        [Event(name="dirtyChanged", type="mx.events.DynamicEvent")]
        [Event(name="editSmartFormItem", type="mx.events.DynamicEvent")]
        [Event(name="selectSmartFormItem", type="mx.events.DynamicEvent")]
        [Event(name="deleteSmartFormItem", type="mx.events.DynamicEvent")]
        [Event(name="addSmartFormItem", type="mx.events.DynamicEvent")]
        [DefaultProperty("itemsAfter")]
    </fx:Metadata>  
    
    <fx:Script>
    <![CDATA[
        import com.rpath.raf.controls.SmartFormButton;
        import com.rpath.raf.models.Descriptor;
        import com.rpath.raf.models.FieldDescriptor;
        import com.rpath.raf.util.DescriptorUtil;
        import com.rpath.raf.util.DictionaryUtils;
        import com.rpath.raf.util.ErrorTipManager;
        import com.rpath.raf.util.IValidationAware;
        import com.rpath.raf.util.UIHelper;
        import com.rpath.raf.util.ValidationHelper;
        import com.rpath.xobj.XObjUtils;
        import com.rpath.xobj.XObjXMLDecoder;
        import com.verveguy.rest.RESThref;
        
        import flashx.textLayout.conversion.FormatDescriptor;
        
        import mx.binding.utils.BindingUtils;
        import mx.binding.utils.ChangeWatcher;
        import mx.collections.ArrayCollection;
        import mx.containers.FormItem;
        import mx.controls.Button;
        import mx.core.IFlexDisplayObject;
        import mx.core.IVisualElement;
        import mx.events.DynamicEvent;
        import mx.events.FlexEvent;
        import mx.events.ValidationResultEvent;
        import mx.utils.ArrayUtil;
        
        import spark.layouts.VerticalLayout;
        
        /*
        
        SmartForms are metadata driven dynamic UI forms
        
        There are a number of places in the rPath API where it is important for the
        client to have information about what data is expected to be sent to the API.
        For example, configuration of targets or of deployed systems are classic cases
        where the client may have to provide quite a lot of specific information to
        effect the configuration.
        
        One of the interesting challenges in this area is how the client *knows* what
        specific data is needed. Rather than hard code the clients to all have
        knowledge of the fact that configuring a VMware target needs name, password,
        resource pool, etc., it is far better for the server to provide some
        additional metadata at *runtime* that describes what is needed. This allows
        each new target, e.g. Eucalyptus and OpenStack, to have entirely different
        configuration information without changing the client code.
        
        The rPath API has evolved a particular construct for this purpose that we call
        a "descriptor".
        
        These descriptors are now used throughout the API including for defining the
        options available for image generation, target configuration settings and,
        with rPath X6, for declaring the configurable properties of a deployed system
        as well as the parameters available for querying the inventory of all deployed
        systems.
        
        A descriptor provides information about a collection of *fields* that make up
        a given data structure required for a given API call. Each field can be
        required or optional, can have a data type (including an enumerated type), can
        be marked as conditional (only relevant if other fields have certain values)
        and can also be constrained in various ways (must match a pattern, etc.)
        
        To keep this to a relatively simple scope, we decided to go with an XML
        representation of these descriptors that looks like this:
        
        <descriptor>
        
        <dataFields>
        
        <field>
        <name>displayName</name>
        <required>true</required>
        <descriptions>
        <desc>Image name</desc>
        </descriptions>
        <prompt>
        <desc>Example: Example System Image for VMware</desc>
        </prompt>
        <type>str</type>
        </field>
        
        <field>
        <name>container.options.swapSize</name>
        <required>false</required>
        <descriptions>
        <desc>Swap space</desc>
        </descriptions>
        <prompt>
        <desc>Example: 512</desc>
        </prompt>
        <type>int</type>
        <default>512</default>
        </field>
        
        
        <field>
        <name>container.options.diskAdapter</name>
        <required>true</required>
        <descriptions>
        <desc>Disk driver</desc>
        </descriptions>
        <prompt>
        <desc>Select the disk driver that the VM should use.</desc>
        </prompt>
        
        <enumeratedType>
        
        <describedValue>
        <descriptions>
        <desc>IDE</desc>
        </descriptions>
        <key>ide</key>
        </describedValue>
        
        <describedValue>
        <descriptions>
        <desc>SCSI (LSILogic)</desc>
        </descriptions>
        <key>lsilogic</key>
        </describedValue>
        
        </enumeratedType>
        <default>lsilogic</default>
        </field>   
        
        </dataFields>
        
        
        Basically, a descriptor consists of a collection of <field> elements grouped
        under a <dataFields> element.
        
        A <field> describes a single property of the resulting data structure. The
        property is identified by the <name> element. For example, the descriptor
        above describes three fields - displayName, container.options.swapSize and
        container.options.diskAdapter.
        
        Each <field> declares a <type> which is one of [int, bool, str]. If omitted,
        <type> is assumed to be a str. A <default> value can also be provided.
        
        Where a defined set of values are allowed, the <enumeratedType> element is a
        collection of <describedValue> elements, each of which defines a permitted
        value for this field as the <key> element.
        
        Note that in order to support user interfaces to work easily with descriptors,
        there are also many elements present that provide human readable labels for
        these various elements. Anticipating multi-language requirements, a <desc>
        element is used which supports an optional lang="en_US" style language
        identifier as an attribute. (Currently, the rPath UI does not support
        languages other than en_US)
        
        Beyond these basic elements, a <field> can also be marked as <conditional>
        with multiple <condition> :
        
        <conditional>
            <fieldName>container.options.diskAdapter</fieldName>
            <operator>noteq</operator>
            <value>lsilogic</value>
        </conditional>
        <conditional>
            <fieldName>container.options.diskAdapter</fieldName>
            <operator>noteq</operator>
            <value>scsi2</value>
        </conditional>
        
        This would make the <field> that contained this element only appear in the UI
        (and only be expected by the server) if the container.options.diskAdapter
        property was not equal to the value 'lsilogic' (and then whatever other
        conditions were in the second <condition> element)
        
        <fields> can also be marked with any number of <constraints> as follows:
        
        <constraints>
        <length>128</length>
        <range>
        <min>0</min>
        <max>2313</max>
        </range>
        <regexp>^.*foo.*$</regexp>
        </constraints>
        
        This allows for user interfaces that provide validation and flagging of user
        errors.
        
        Finally, the descriptor must also contain a <metadata> element that provides 
        a Form Heading
        
        <metadata>
        <displayName>CloudInfo</displayName>
        <descriptions>
        <desc>The Form Heading text you want</desc>
        </descriptions>
        </metadata>
        
        */
        
        /** TODO: make this the new metadata carrier rather than literal XML
         */
        [Bindable]
        public var formDescriptor:Descriptor;
        
        [Bindable]
        public var showHeading:Boolean = true;
        
        [Bindable]
        public function get metadata():XML
        {
            return _metadata;
        }
        
        private var _metadata:XML;
        private var metadataList:XMLList;
        private var descriptionsList:XMLList;
        private var fieldsList:XMLList;
        private var metadataNS:Namespace;
        private var _metadataChanged:Boolean;
        
        public function set metadata(m:XML):void
        {
            if (!(_metadata === m))
            {
                //trace("metadata change " + this.uid);
                _metadata = m;
                
                _metadataChanged = true;
                _needsRebuilding = true;
                // make sure defaults are re-eval'd
                firstTime = true;
                invalidateProperties();
            }
        }
        
        public var itemsBefore:Array;
        
        public var itemsAfter:Array;
        
        [Bindable]
        public function set editable(v:Boolean):void
        {
            _formEditable = v;
            
            _formEditableChanged = true;
            invalidateProperties();
        }
        
        private var _formEditable:Boolean = true;
        private var _formEditableChanged:Boolean;
        
        public function get editable():Boolean
        {
            return _formEditable;
        }        
        
        [Bindable]
        public var enableFormDefinitionEditing:Boolean;
        
        [Bindable]
        public var enableFormDefinitionDelete:Boolean;
        
        [Bindable]
        public var showLang:Boolean;
        
        [Bindable]
        public override function set enabled(v:Boolean):void
        {
            _formEnabled = v;
        }
        
        private var _formEnabled:Boolean = true;
        
        
        public override function get enabled():Boolean
        {
            return _formEnabled;
        }
        
        /**
         * Whether or not to allow defaults on items.  This may need to be turned
         * off in scenarios where defaults are overriding pre-set values.
         */ 
        [Bindable]
        public var allowItemDefaults:Boolean = true;
        
        [Bindable]
        public var heading:String = "";
        
        /** discreteControlThreshold controls when we switch from checkbox/radiobutton
         * to a pulldown menu
         */
        [Bindable]
        public var discreteControlThreshold:int = 4;
        
        /** menuControlThreshold controls when we switch from a pulldown menu to 
         * to a listbox 
         */    
        [Bindable]
        public var menuControlThreshold:int = 10;
        
        [Bindable]
        public var longTextThreshold:int = 40;
        
        [Bindable]
        public var multiCheckLabelLengthThreshold:int = 11;
        
        [Bindable]
        public var labelLengthThreshold:int = 13;
        
        [Bindable]
        public function get validationHelper():ValidationHelper
        {
            return _validationHelper;
        }
        
        private var _validationHelper:ValidationHelper;
        
        public function set validationHelper(v:ValidationHelper):void
        {
            _validationHelper = v;
        }
        
        private var watchers:Array;
        
        /** keep track of our entire data object changing - e.g. during
         * initialization or re-initialization if the form is reused
         */
        
        private var _dataObjectChanged:Boolean;
        
        [Bindable]
        // see https://issues.rpath.com/browse/RCE-928 for why this defaults to true
        public var createOnDemand:Boolean = true;
        
        [Bindable("dataChange")]
        public override function set data(v:Object):void
        {
            if (super.data != v)
            {
                super.data = v;
                //trace("data change " + this.uid);
                // unbind things, since we no longer want to change the old data object
                // nor do we want the old data object changing us
                unbindWatchers();
                _needsRebinding = true;
                _dataObjectChanged = true;
                invalidateProperties();
            }
        }
        
        public function flushData():void
        {           
            //trace("data change " + this.uid);
            // unbind things, since we no longer want to change the old data object
            // nor do we want the old data object changing us
            _needsRebuilding = true;
            invalidateProperties();
        }
        
        public override function get data():Object
        {
            return super.data;
        }
        
        public function newDataHolderForItem(item:SmartFormItem):*
        {
            var propName:String = item.fieldDescriptor.name;
            
            return newDataHolder(XObjUtils.getClassForProperty(data, propName));
        }
        
        public function newDataHolder(type:Class=null):*
        {
            // TODO: figure out how to make this the right TYPE
            if (!type)
                type = Object;
            return new type(); 
        }
        
        // set this true by default to ensure we get initial refresh
        private var _needsRebuilding:Boolean;
        
        private var _needsRebinding:Boolean;
        
        
        private function addWatcher(propName:String, item:*):void
        {
            var cw:ChangeWatcher;
            
            if (data)
            {            
                cw = BindingUtils.bindSetter(
                    function f(value:*):void
                    {
                        setProperty(data, propName, value);
                    },
                    item, [ "data" ], false, true);
            }
            
            if (!watchers)
                watchers = new Array();
            watchers.push({prop:propName, item: item, watcher:cw});
        }
        
        private function unbindWatchers():void
        {
            if (watchers)
            {
                for each (var w:* in watchers)
                {
                    if (w.watcher)
                    {
                        w.watcher.unwatch();
                        w.watcher = null;
                    }
                }
            }
        }
        
        private function rebindWatchers():void
        {
            if (watchers)
            {
                for each (var w:* in watchers)
                {
                    // NOTE: we need to pull any data from the data object
                    // into the form FIRST, since the data object has changed in
                    // this case (that's what led to the rebind requirement)
                    w.watcher = binder(w);
                    // give the item a chance to snapshot data
                    if (w.item.hasOwnProperty("snapshotData"))
                        w.item.snapshotData();
                }
            }
        }
        
        // we have to put this in a distinct function to ensure that the anon func
        // gets a fresh variable ref for each invocation. If you just put this in
        // the foreach loop above, all funcs when invoked will reference the same
        // value of w. (i.e the last one visited in the loop) GOTCHA!
        private function binder(w:Object):ChangeWatcher
        {
            return BindingUtils.bindSetter(
                function f(value:*):void
                {
                    setProperty(data, w.prop, value);
                },
                w.item, [ "data" ], false, true);
        }
        
        private function removeWatchers():void
        {
            if (watchers)
            {
                for each (var w:* in watchers)
                {
                    if (w.watcher)
                        w.watcher.unwatch();
                }
                watchers = new Array();
            }
        }
        
        private var idGen:int;
        
        public override function invalidateProperties():void
        {
            ////trace("smartform invalidateProps " + this.uid);
            super.invalidateProperties();
        }
        
        protected override function commitProperties():void
        {       
            // necessary hack to get the form to scrollbar properly
            minHeight=0;
            
            if (_metadataChanged)
            {
                _metadataChanged = false;
                
                if (metadata)
                {
                    metadataNS = metadata.namespace();
                    if (!metadataNS)// seems we can have an empty XML (non null) with no namepsace
                        metadataNS = new Namespace();
                    
                    metadataList = metadata.metadataNS::metadata;
                    descriptionsList = metadata.metadataNS::metadata.metadataNS::descriptions;
                    var dataFields:XMLList;
                    dataFields = metadata.metadataNS::dataFields;
                    if (dataFields.length() > 0)
                    {
                        fieldsList = dataFields.metadataNS::field;
                    }
                    else
                        fieldsList = null;
                    
                    // also digest into non-XML format
                    if (!formDescriptor)
                    {
                        formDescriptor = Descriptor.fromXML(metadata);
                    }
                }
                else
                {
                    metadataNS = new Namespace();
                    metadataList = null;
                    descriptionsList = null;
                }
            }
            
            if (_formEditableChanged)
            {
                _formEditableChanged = false;
                // TODO: add/remove the placeholder item that has ADD button on it
                _needsRebuilding = true;
            }
            
            if (_itemDataChanged)
            {
                revisitConditions();
                if (!_childDirtyChanged)
                {
                    checkDirty();
                }
                
                _itemDataChanged = false;
            }
            
            if (_childDirtyChanged)
            {
                checkDirty();
                _childDirtyChanged = false;
            }
            
            if (_needsRebuilding)
            {
                //trace("smartform commit REBUILD" + this.uid);
                _needsRebuilding = false;
                _needsRebinding = false;
                removeFormItems();
                createFormItems();
                checkDirty();
                
                this.setFocus();
                
                // after the rebuild, clear any change flag
                _conditionsChanged = false;
            }
            else if (_needsRebinding)
            {
                //trace("smartform commit REBIND" + this.uid);
                _needsRebinding = false;
                rebindWatchers();
                checkDirty();
            }
            
            
            super.commitProperties();
            
        }
        
        
        private var conditions:Array;
        
        private function evalCondition(condition:Object):Boolean
        {
            var result:Boolean;
            
            if (data != null)
            {
                var dataVal:Object;
                var stringVal:String;
                
                dataVal = getProperty(data, condition.property);
                stringVal = dataVal == null ? null : dataVal.toString();
                
                if (/noteq.*/.exec(condition.operator.toLowerCase()))
                {
                    result = (stringVal != condition.value);
                }
                    
                else if (/eq.*/.exec(condition.operator.toLowerCase()))
                {
                    result = (stringVal == condition.value);
                }
                
            }
            
            // note the result for future comparison
            condition.result = result;
            
            return result;
        }
        
        private function clearConditions():void
        {
            conditions = new Array();
        }
        
        private function addCondition(prop:String, op:String, val:String):Object
        {
            if (!prop || !op )
                return null;
            
            var condition:Object = {property: prop, operator: op, value: val, result:false};
            conditions.push(condition);
            
            // we need to hear about changes to the data object for this property so 
            // that we can trigger form rebuild on conditional change
            // how to do this generically? we need to do it on the data not ont he UI
            // since the data may change outside UI control
            
            // BindSetter only works with known properties - not truly dynamic ones
            // need an object proxy here?
            
            //RAFBindingUtils.bindSetter(revisitConditions, this, ["data", prop]);
            
            return condition;
        }
        
        private var _conditionsChanged:Boolean;
        
        private function revisitConditions():void
        {
            if (checkConditionChanged())
            {
                // one or more of the conditionals have changed result
                // so rebuild everything
                _conditionsChanged= true;
                _needsRebuilding = true;
                invalidateProperties();
            }
        }
        
        private function removeCondition(prop:String, op:String, val:String):void
        {
            for each (var condition:Object in conditions)
            {
                if (condition.property == prop && condition.operator == op && condition.value == val)
                {
                    conditions.splice(conditions.indexOf(condition), 1);
                }
            }
        }
        
        private function checkConditionChanged():Boolean
        {
            for each (var condition:Object in conditions)
            {
                var oldResult:Boolean = condition.result;
                if (oldResult != evalCondition(condition))
                {
                    return true;
                }
            }
            
            return false;
        }
        
        /** firstTime tracks whether we've created form items before
         * This is important because we need to initialize the default
         * values of the data object properties from the descriptor
         * iff this is the first time we're doing so
         */
        private var firstTime:Boolean = true;
        
        
        public function get errorTipManager():ErrorTipManager
        {
            return _errorTipManager;
        }
        
        private var _errorTipManager:ErrorTipManager;
        
        public function set errorTipManager(v:ErrorTipManager):void
        {
            _errorTipManager = v;
            if (validationHelper)
                validationHelper.errorTipManager = _errorTipManager;
        }
        
        
        /** createFormItems iterates the descriptor and creates, binds and sets 
         * initial default values for every form item described in the descriptor
         */
        
        private function createFormItems():void
        {
            var pendingItems:ArrayCollection = new ArrayCollection();
            var sections:Dictionary = new Dictionary();
            
            validationHelper = new ValidationHelper(null,this,"isValid");
            
            // now add any other children
            for each (var item:* in itemsBefore)
            {
                addChild(item);
                
                validationHelper.addItemToValidate(item);
            }
            
            if (metadata)
            {
                
                //trace("create form items " + this.uid);
                heading = DescriptorUtil.localeDescString(descriptionsList, metadataNS);
                
                // clear all conditions and start afresh
                clearConditions();
                
                var conditionalList:XMLList;
                for each (var field:XML in fieldsList)
                {
                    // flag to track whether we've defaulted the field or not
                    var applyDefault:Boolean = false;
                    var hasADefault:Boolean = false;
                    var propName:String = field.metadataNS::name;
                    var meetsCondition:Boolean = true;
                    var condition:Object = null;
                    
                    conditionalList = field.metadataNS::conditional;
                    if (conditionalList.length() > 0)
                    {
                        // evaluate condition and queue condition on any change to the value object
                        for each (var cond:XML in conditionalList)
                        {
                            condition = addCondition(cond.metadataNS::fieldName, cond.metadataNS::operator, cond.metadataNS::value);
                            if (condition)
                                meetsCondition = meetsCondition && evalCondition(condition);
                        }
                        
                    }
                    
                    if (meetsCondition)
                    {
                        /*
                        Allow conditional, hidden fields with defaults to actually set the default value 
                        on the data object even though they're hidden. However, if they're conditional
                        is false, don't set the default value. Confused? I'm not.
                        */
                        
                        //TODO: handle the potential race condition where data is NULL by moving this
                        // into the SmartFormItem so it can be deferred
                        if (data)
                        {
                            // ugly QName indirection to avoid direct expression of the 
                            // default keyword in . expression
                            var defaultNode:XMLList = field[new QName(metadataNS,"default")];
                            if (firstTime && (defaultNode.length() > 0) && allowItemDefaults)
                            {
                                var value:* = getProperty(data, propName);
                                var newValue:* = null;
                                
                                // First, extract the default value
                                
                                // single or multi-valued default?
                                if (defaultNode.length() == 1)
                                {
                                    newValue = defaultNode.toString();
                                }
                                else
                                {
                                    newValue = [];
                                    for each (var val:XML in defaultNode)
                                    {
                                        var def:String = val.toString();
                                        newValue.push(def);
                                    }
                                }
                                
                                // second, decide where to apply it
                                
                                // BASIC RULES
                                
                                
                                if (data.hasOwnProperty(propName))
                                {
                                    if ((value == null) || (value == undefined) || (value is Number && isNaN(value))
                                        || ((value is Array || value is ArrayCollection) && (value.length == 0)))
                                    {
                                        // If property defined, but NULL and REQUIRED, set default
                                        applyDefault = true;
                                    }
                                    else
                                    {
                                        // if property defined, but NULL and INVALID, set default (general case of REQUIRED)
                                        // TODO: check validity somehow...too early right now
                                        
                                        // if property defined and non-NULL, leave it alone
                                    }
                                }
                                else
                                {
                                    // If property not defined, set default
                                    applyDefault = true;
                                }
                            }
                        }
                        
                        if (applyDefault)
                        {
                            // now should we set the value at all?
                            if (value is Array || value is ArrayCollection)
                            {
                                setProperty(data, propName, ArrayUtil.toArray(newValue));
                            }
                            else 
                            {
                                setProperty(data, propName, newValue);
                            }
                            
                            hasADefault = true; // track at least one default applied...
                        }
                        
                        // skip hidden fields
                        if (field.metadataNS::hidden.toString().toLowerCase() == "true")
                            continue;
                        
                        var newItem:SmartFormItem = new SmartFormItem()
                        newItem.metadataNS = metadataNS;
                        newItem.smartForm = this;
                        // make sure changes to the data object propagate to the control
                        var propChain:Array = propName.split('.');
                        BindingUtils.bindSetter(itemDataSetterWrapper(newItem), this, ["data"].concat(propChain), false, false);
                        BindingUtils.bindProperty(newItem, "enableFormDefinitionEditing", this, ["enableFormDefinitionEditing"], false, false);
                        BindingUtils.bindProperty(newItem, "enableFormDefinitionDelete", this, ["enableFormDefinitionDelete"], false, false);
                        BindingUtils.bindProperty(newItem, "createOnDemand", this, ["createOnDemand"], false, false);
                        
                        //newItem.addEventListener("addSmartFormDataObject", addDataObject, false, 0, true);
                        
                        // make sure changes to the control propagate to the data object
                        addWatcher(propName, newItem);
                        
                        newItem.metadata = field;
                        
                        // extract the section metadata
                        sections[newItem.section_key] = newItem.section_desc ? newItem.section_desc : formatSectionLabel(newItem.section_key);
                        
                        if (formDescriptor)
                        {
                            var desc:FieldDescriptor = formDescriptor.findFieldByUID(field.metadataNS::uid.toString());
                            if (!desc)
                            {
                                // try again by name 
                                desc = formDescriptor.findFieldByName(field.metadataNS::name);
                            }
                            newItem.fieldDescriptor = desc;
                        }
                        
                        newItem.id = "formItem" + (idGen++);
                        BindingUtils.bindProperty(newItem, "editable", this, [ "editable"], false, false);
                        BindingUtils.bindProperty(newItem, "enabled", this, [ "enabled"], false, false);
                        BindingUtils.bindProperty(newItem, "showLang", this, [ "showLang"], false, false);
                        
                        newItem.errorTipManager = errorTipManager;
                        validationHelper.addItemToValidate(newItem);
                        
                        // updated - 2011-04-07 - RBL-8357                    
                        //                    if (hasADefault)
                        //                    {
                        //                        // kick a validation now on this field to ensure default itself is
                        //                        // valid. See RBL-8357
                        //                        newItem.validate();
                        //                    }
                        
                        //newItem.addEventListener(ValidationResultEvent.VALID, handleValidationEvent,false,0,true);
                        //newItem.addEventListener(ValidationResultEvent.INVALID, handleValidationEvent,false,0,true);
                        
                        newItem.addEventListener(FlexEvent.DATA_CHANGE, handleItemDataChange,false,0,true);
                        newItem.addEventListener("dirtyChanged", handleDirtyEvent,false,0,true);
                        
                        // give the item a chance to stash the orig data value for dirty detection
                        // unless this is a rebuild due to conditional values changing
                        if (!_conditionsChanged)
                        {
                            newItem.snapshotData();
                        }
                        
                        // add field to a queue of pending fields
                        pendingItems.addItem(newItem);
                        
                        // track the first item in the smartform for label computation 
                        // see onCreationComplete()
                        if (firstItem == null)
                            firstItem = newItem;
                    }
                    else
                    {
                        // we did not meet the condition, so REMOVE the property we represent 
                        // from the underlying data object
                        
                        // TODO: THIS GETS HAIRY because it may be that there's multiple, duplicative fields
                        // that have mutually exclusive conditions. We don't want to delete a property that 
                        // is actually defined by another field in the descriptor
                        if (data)
                            delete data[propName];
                    }
                }
                
                firstTime = false;
            }
            
            // now add the items in section order
            var section_keys:Array = DictionaryUtils.getKeys(sections);
            section_keys.sort();
            for each (var section_key:String in section_keys)
            {
                // TODO: add section container 
                // label = sections[section_key]
                var scon:DisclosureContainer;
                var vlayout:VerticalLayout = new VerticalLayout(); 
                vlayout.gap = 0;
                var sconForm:Form;
                
                scon = null;
                sconForm = null;
                
                if (section_key)
                {
                    scon = new DisclosureContainer();
                    this.addChild(scon);
                    scon.percentWidth = 100;
                    scon.disclosureLabel = sections[section_key];
                    scon.layout = vlayout;
                    scon.expanded = true;
                    
                    sconForm = new Form();
                    scon.addElement(sconForm);
                    sconForm.percentWidth = 100;
                    scon.setStyle("labelWidth", 175);
                    scon.setStyle("paddingTop", 0);
                    
                    if (enableFormDefinitionEditing)
                    {
                        var sectionFieldButton:SmartFormButton = new SmartFormButton();
                        scon.addElement(sectionFieldButton);
                        sectionFieldButton.label = "Add section property";
                        sectionFieldButton.addEventListener(MouseEvent.MOUSE_DOWN, sectionFieldButtonHandler);
                        sectionFieldButton.data = {key: section_key, value: sections[section_key]};
                    }
                    
                }
                
                for each (newItem in pendingItems)
                {
                    if (newItem.section_key == section_key)
                    {
                        if (sconForm)
                            sconForm.addChild(newItem);
                        else
                            this.addChild(newItem);
                    }
                }
            }
            
            // now add any other children
            for each (var itemAfter:* in itemsAfter)
            {
                addChild(itemAfter);
                validationHelper.addItemToValidate(itemAfter);
            }
            
            
            
            // removing this to fix https://issues.rpath.com/browse/RCE-961 - not sure it's needed anymore -jb
            
            // now finally, if editable, add the placeholder item
//            if (enableFormDefinitionEditing)
//            {
//                newItem = new SmartFormItem();
//                /* newItem.label = "ADD"; */
//                newItem.id = "addPlaceholder";
//                newItem.smartForm = this;
//                newItem.enableFormDefinitionEditing = true; // the whole point
//                // track the first item in the smartform for label computation 
//                // see onCreationComplete()
//                if (firstItem == null)
//                    firstItem = newItem;
//                addChild(newItem);
//            }
            
        }
        
        private function sectionFieldButtonHandler(event:MouseEvent):void
        {
            var e:DynamicEvent = new DynamicEvent("addSmartFormItem");
            e.section = event.currentTarget.data;
            dispatchEvent(e);
        }
        
        protected function formatSectionLabel(str:String):String
        {
            if (str =="")
                return "";
            
            var words:Array = str.split("_");
            var i:int = 0
            for each (var word:String in words)
            {
                words[i] = word.charAt(0).toUpperCase() + word.substr(1);
                i++;
            }
            str = words.join(" ");
            return str;
        }
        
        private function itemDataSetterWrapper(newItem:SmartFormItem):Function
        {
            return function setter(value:*):void
            {
                newItem.data = value;
            }
        }
        
        protected function getProperty(obj:*, propName:String):*
        {
            var bits:Array = propName.split('.');
            var o:*;
            
            o = obj;
            for each (var prop:String in bits)
            {
                try
                {
                    o = o[prop];
                }
                catch (e:Error)
                {
                    return null;
                }
            }
            return o;
        }
        
        protected function setProperty(obj:*, propName:String, value:*):void
        {
            var bits:Array = propName.split('.');
            var o:*;
            var last:String = bits.pop();
            
            o = obj;
            try
            {
                for each (var prop:String in bits)
                {
                    var newo:*;
                    newo = o[prop];
                    
                    // create objects on demand if not exist
                    if (newo == undefined) //  && createOnDemand
                    {
                        newo = newDataHolder(XObjUtils.getClassForProperty(o, prop));
                        o[prop] = newo;
                    }
                    o = newo;
                }
                
                try
                {
                    var cur:* = o[last];
                    if ((cur is Boolean) && (value is String))
                    {
                        // special case to handle "false" and "true" as strings
                        o[last] = UIHelper.boolValue(value as String);
                    }
                    else if ((cur is RESThref) && (value is String))
                    {
                        // re-write new HREF to force update
                        o[last] = new RESThref(value);
                        // href.value != href.href
                        (o[last] as RESThref).href = value;
                    }
                    else
                        o[last] = value;
                }
                catch (e:Error)
                {
                }
                
            }
            catch (e:Error)
            {
                
            }
        }
        
        /** keep track of data value changes by our form items
         */
        private var _itemDataChanged:Boolean;
        
        private function handleItemDataChange(event:FlexEvent):void
        {
            _itemDataChanged = true;
            invalidateProperties();
        }
        
        private function removeFormItems():void
        {
            removeWatchers();
            
            var length:int = this.numChildren;
            for (var count:int = 1; count < length; count++)
            {
                removeChildAt(1);
            }
            
            if (validationHelper)
            {
                validationHelper.removeAllValidators();
                validationHelper = null;
            }
            
            if (errorTipManager)
            {
                errorTipManager.reset();
                errorTipManager = null;
            }
            
        }
        
        // ------------------------------------------------ VALIDATION
        
        [Bindable]
        public function get isValid():Boolean
        {
            return _isValid;
        }
        
        private var _isValid:Boolean = true;;
        
        public function set isValid(v:Boolean):void
        {
            _isValid = v;
            //dispatchEvent(new FlexEvent(_isValid ? FlexEvent.VALID : FlexEvent.INVALID));
        }
        
        private var _directValid:Boolean = true;
        
        public override function validationResultHandler(event:ValidationResultEvent):void
        {
            /*          _directValid = (event.type == ValidationResultEvent.VALID);
            // check our children too
            handleValidationEvent();
            super.validationResultHandler(event);  */
        }
        
        private var invalidItems:int;
        
        public function handleValidationEvent(event:FlexEvent=null):void
        {
            /*  var newValid:Boolean = true;
            
            for each (var child:* in this.getChildren())
            {
            if (child is SmartFormItem)
            if (!child.isValid)
            {
            newValid = false;
            break;
            }
            }
            
            isValid = newValid && _directValid;
            
            // rethrow the validation event should anyone else want it
            // catch it regardless of location
            this.dispatchEvent(new FlexEvent(isValid ? FlexEvent.VALID : FlexEvent.INVALID, true));  */
        }
        
        /** validate forces a validation pass and pops all error flags
         */
        public function validate(suppressErrors:Boolean=false):void
        {
            if (!isValid)
            {
                for each (var child:* in this.getChildren())
                {
                    if (child is SmartFormItem)
                    {
                        //(child as SmartFormItem).validate();
                    }
                }
            }
        }
        
        /** showErrors just pops any errors we're already aware of. It does NOT
         * validate the form for current status
         */
        
        public function showErrors():void
        {
            // validate and pop errors as we find them
            validationHelper.showErrors();
        }
        
        public function hideErrors():void
        {
            validationHelper.hideErrors();
        }
        
        // ---------------------------------------------------- DIRTY TRACKING
        
        
        [Bindable]
        public function set isDirty(b:Boolean):void
        {
            _isDirty = b;
            this.dispatchEvent(new DynamicEvent("dirtyChanged",true));
            
            // aslo mark the data object dirty if it has such a property
            if (data && data.hasOwnProperty("isDirty"))
            {
                data.isDirty = b;
            }
        }
        
        private var _isDirty:Boolean = false;
        
        public function get isDirty():Boolean
        {
            return _isDirty;
        }
        
        public var _childDirtyChanged:Boolean;
        
        protected var dirty_children:Dictionary = new Dictionary(true);
        
        public function handleDirtyEvent(event:Event):void
        {
            var item:* = event.target;
            if (!dirty_children[item])
                dirty_children[item] = item;
            
            _childDirtyChanged = true;
            invalidateProperties();
        }
        
        
        public function checkDirty():void
        {
            var dirtyKeys:Array = DictionaryUtils.getKeys(dirty_children);
            if (dirtyKeys.length < 1)
                return;
            
            
            var newDirty:Boolean = false;
            
            for each (var item:* in dirty_children)
            {
                if (dirty_children[item].hasOwnProperty("isDirty"))
                    {
                        if (dirty_children[item].isDirty)
                        {
                            newDirty = true;
                            break;
                        }
                        else
                        {
                            delete dirty_children[item];
                        }
                    }
            }
            
            isDirty = newDirty;
        }
        
        
        // -----------------------------------------------------------------------
        
        public override function setFocus():void
        {
            for each (var child:* in this.getChildren())
            {
                if (child is FormItem)
                {
                    child.setFocus();
                    break;
                }
            }
        }
        
        /*     override public function get defaultButton():IFlexDisplayObject
        {
        return super.defaultButton;
        }
        
        
        private var dw:ChangeWatcher;
        
        override public function set defaultButton(value:IFlexDisplayObject):void
        {
        super.defaultButton = value;
        // also hook up enabled/disabled status on the default isValid
        if (dw)
        dw.unwatch();
        
        if (value)
        {
        dw = BindingUtils.bindProperty(value, "enabled",
        this, ["isValid"],false,true);
        }
        } */
        
        private var firstItem:FormItem;
        
        public function onCreationComplete(event:Event):void
        {
            // DISGUSTING HACK TO WORKAROUND ADOBE BUG
            // Turns out, FormItems that have their labels computed
            // fail to invalidate the Form's idea of labelWidth
            // until AFTER the form is fully initialized.
            // So we have to force the issue here
            
            /*         if (validationHelper)
            validationHelper.errorTipManager.suppressErrors = false;
            */     
            
            
            // removing this to fix https://issues.rpath.com/browse/RCE-961 - not sure it's needed anymore -jb
//            if (firstItem)
//            {
//                var oldLabel:String = firstItem.label;
//                firstItem.label = "";
//                firstItem.label = oldLabel;
//            }
//            
            // allow for a SmartForm with NO metadata but just hard wired items
            
            if (metadata == null && ((itemsAfter && itemsAfter.length > 0)
                || (itemsBefore && itemsBefore.length > 0)))
            {
                _needsRebuilding = true;
                _needsRebinding = true;
                invalidateProperties();
            }
        }
        
    ]]>
    </fx:Script>
    
    <mx:FormHeading id="formHead" label="{heading}" includeInLayout="{showHeading}" visible="{formHead.includeInLayout}"/>
    
</mx:Form>
