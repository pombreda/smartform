<?xml version="1.0" encoding="utf-8"?>

<!--

ADOBE SYSTEMS INCORPORATED
Copyright 2008 Adobe Systems Incorporated
All Rights Reserved.

NOTICE: Adobe permits you to use, modify, and distribute this file
in accordance with the terms of the license agreement accompanying it.

-->

<!--
Copyright (c) 2009-2011 rPath, Inc.

This program is distributed under the terms of the MIT License as found 
in a file called LICENSE. If it is not present, the license
is always available at http://www.opensource.org/licenses/mit-license.php.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of merchantability
or fitness for a particular purpose. See the MIT License for full details.
-->

<!--- The default skin class for Spark TextArea component.  

@see spark.components.TextArea

@langversion 3.0
@playerversion Flash 10
@playerversion AIR 1.5
@productversion Flex 4
-->
<s:SparkSkin xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark"
             xmlns:fb="http://ns.adobe.com/flashbuilder/2009" alpha.disabled="0.5" blendMode="normal">
    
    <fx:Metadata>
        <![CDATA[ 
        /** 
        * @copy spark.skins.spark.ApplicationSkin#hostComponent
        */
        [HostComponent("com.rpath.raf.controls.AdvancedTextArea")]
        ]]>
    </fx:Metadata> 
    
    <fx:Script fb:purpose="styling">
        private var lineBreakChanged:Boolean;
        private var paddingChanged:Boolean;
        private var verticalAlignChanged:Boolean;
        
        /* Define the skin elements that should not be colorized. 
        For text area, the skin itself is colorized but the individual parts are not. */
        //static private const exclusions:Array = ["background", "scroller"];
        static private const exclusions:Array = [ "scroller"];
        
        /**
         * @private
         */   
        override public function get colorizeExclusions():Array {return exclusions;}
        
        /**
         *  @private
         */
        override protected function commitProperties():void
        {
            
            if (lineBreakChanged)
            {
                updateStringStyle("lineBreak");
                lineBreakChanged = false;
            }
            if (paddingChanged)
            {
                updatePadding();
                paddingChanged = false;
            }
            if (verticalAlignChanged)
            {
                updateStringStyle("verticalAlign");
                verticalAlignChanged = false;
            }
            super.commitProperties();
        }
        
        /**
         * @private
         */
        override protected function initializationComplete():void
        {
            useChromeColor = true;
            super.initializationComplete();
        }
        
        /**
         *  @private
         */
        override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
        {
            if (getStyle("borderVisible") == true)
            {
                border.visible = true;
            }
            else
            {
                border.visible = false;
            }
            
            super.updateDisplayList(unscaledWidth, unscaledHeight);
        }
        
        /**
         *  @private
         */
        private function updatePadding():void
        {
            if (!textDisplay)
                return;
            
            // Push padding styles into the textDisplay
            var padding:Number;
            
            padding = getStyle("paddingLeft");
            if (textDisplay.getStyle("paddingLeft") != padding)
                textDisplay.setStyle("paddingLeft", padding);
            
            padding = getStyle("paddingTop");
            if (textDisplay.getStyle("paddingTop") != padding)
                textDisplay.setStyle("paddingTop", padding);
            
            padding = getStyle("paddingRight");
            if (textDisplay.getStyle("paddingRight") != padding)
                textDisplay.setStyle("paddingRight", padding);
            
            padding = getStyle("paddingBottom");
            if (textDisplay.getStyle("paddingBottom") != padding)
                textDisplay.setStyle("paddingBottom", padding);
        }
        
        /**
         *  @private
         */
        private function updateStringStyle(styleName:String):void
        {
            if (!textDisplay)
                return;
            
            // Push style into the textDisplay
            var style:String;
            
            style = getStyle(styleName);
            if (textDisplay.getStyle(styleName) != style)
                textDisplay.setStyle(styleName, style);
        }
        
        /**
         *  @private
         */
        override public function styleChanged(styleProp:String):void
        {
            var allStyles:Boolean = !styleProp || styleProp == "styleName";
            
            super.styleChanged(styleProp);
            
            if (allStyles || styleProp.indexOf("lineBreak") == 0)
            {
                lineBreakChanged = true;
                invalidateProperties();
            }
            if (allStyles || styleProp.indexOf("padding") == 0)
            {
                paddingChanged = true;
                invalidateProperties();
            }
            if (allStyles || styleProp.indexOf("verticalAlign") == 0)
            {
                verticalAlignChanged = true;
                invalidateProperties();
            }
        }
    </fx:Script>
    
    <fx:Script>
        <![CDATA[
            /** 
             * @private 
             */     
            private static const focusExclusions:Array = ["textDisplay"];
            
            /**
             *  @private
             */
            override public function get focusSkinExclusions():Array { return focusExclusions;};
            
            protected function showPrompt(state:String, text:String):Boolean
            {
                return (state != "focused" && text == "");
            }
            
        ]]>
    </fx:Script>
    
    <s:states>
        <s:State name="normal"/>
        <s:State name="normalWithPrompt" />
        <s:State name="disabled" />
        <s:State name="disabledWithPrompt"/>
        <s:State name="focused"/>
    </s:states>
    
    <s:transitions>
        <s:Transition fromState="normal" toState="focused" >
            <s:Fade duration="350" target="{promptView}" />
        </s:Transition> 
        <s:Transition fromState="focused" toState="normal" >
            <s:Fade duration="350" target="{promptView}" />
        </s:Transition> 
    </s:transitions>
    
    <!-- put everything in a group to make room for the focus border-->
    <s:Group left="1" right="1" top="1" bottom="1"
             >
        
        
        
        <!-- fill -->
        <!--- Defines the appearance of the TextInput component's background. -->
        <!--- @private Defines the background fill color. -->
        <!--<s:Rect id="background" left="1" right="1" top="1" bottom="1">
            <s:fill>
                <s:SolidColor color="{getStyle('backgroundColor')}" />
            </s:fill>
        </s:Rect>-->
        <!--
        <s:Rect id="gradient" left="1" right="1" top="1" bottom="1">
            <s:fill>
                <s:LinearGradient rotation="90" >
                    <s:GradientEntry color="0x000000" alpha=".1"/>
                    <s:GradientEntry color="0x000000" alpha="0"/>
                    <s:GradientEntry color="0x000000" alpha="0"/>
                </s:LinearGradient>
            </s:fill>
        </s:Rect>-->
        
        <!-- border --> 
        <!--- @private -->
        <s:Rect left="0" right="0" top="0" bottom="0" id="border">
            <s:stroke>     
                <!--- @private -->
                <s:SolidColorStroke id="borderStroke" weight="1" color="{getStyle('borderColor')}" />
            </s:stroke>
        </s:Rect>
        
        <!--- Defines the scroller that is used to scroll the TextArea control. -->
        <s:Scroller id="scroller" left="0" top="0" right="0" bottom="0" minViewportInset="1" 
                    measuredSizeIncludesScrollBars="false" hasFocusableChildren="false">
            <!--- @copy spark.components.supportClasses.SkinnableTextBase#textDisplay -->
            <s:RichEditableText id="textDisplay"
                                heightInLines.normal="{hostComponent.autoResize ? 4 : 10}"
                                heightInLines.focused="10"
                                widthInChars="15" />
        </s:Scroller>
        
        <!-- prompt -->
        <s:Label 
            id="promptView"
            text="{hostComponent.prompt}"
            bottom="1"
            left="1"
            paddingBottom="3"
            paddingLeft="3"
            paddingRight="3"
            paddingTop="5"
            right="1"
            top="1"
            lineBreak="explicit"
            visible="{showPrompt(currentState, hostComponent.text)}"
            styleName="formItemPromptText"
            />
    </s:Group>
    
</s:SparkSkin>
