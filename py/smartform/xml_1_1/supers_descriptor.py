#!/usr/bin/env python

#
# Generated  by generateDS.py.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class descriptorType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('version', 'xsd:string', 0),
        MemberSpec_('id', 'xsd:anyURI', 0),
        MemberSpec_('metadata', 'metadataType', 0),
        MemberSpec_('dataFields', 'dataFieldsType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, version=None, id=None, metadata=None, dataFields=None):
        self.version = _cast(None, version)
        self.id = _cast(None, id)
        self.metadata = metadata
        self.dataFields = dataFields
    def factory(*args_, **kwargs_):
        if descriptorType.subclass:
            return descriptorType.subclass(*args_, **kwargs_)
        else:
            return descriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_dataFields(self): return self.dataFields
    def set_dataFields(self, dataFields): self.dataFields = dataFields
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='dsc:', name_='descriptorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='descriptorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='descriptorType'):
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None:
            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='descriptorType'):
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
        if self.dataFields:
            self.dataFields.export(outfile, level, namespace_, name_='dataFields', )
    def hasContent_(self):
        if (
            self.metadata is not None or
            self.dataFields is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='descriptorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.metadataType(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataFields is not None:
            showIndent(outfile, level)
            outfile.write('dataFields=model_.dataFieldsType(\n')
            self.dataFields.exportLiteral(outfile, level, name_='dataFields')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            self.version = attrs.get('version').value
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'metadata':
            obj_ = metadataType.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dataFields':
            obj_ = dataFieldsType.factory()
            obj_.build(child_)
            self.set_dataFields(obj_)
# end class descriptorType


class metadataType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('displayName', 'xsd:string', 0),
        MemberSpec_('rootElement', 'xsd:string', 0),
        MemberSpec_('descriptions', 'descriptionsType', 0),
        MemberSpec_('supportedFiles', 'supportedFilesType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, displayName=None, rootElement=None, descriptions=None, supportedFiles=None):
        self.displayName = displayName
        self.rootElement = rootElement
        self.descriptions = descriptions
        self.supportedFiles = supportedFiles
    def factory(*args_, **kwargs_):
        if metadataType.subclass:
            return metadataType.subclass(*args_, **kwargs_)
        else:
            return metadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_rootElement(self): return self.rootElement
    def set_rootElement(self, rootElement): self.rootElement = rootElement
    def get_descriptions(self): return self.descriptions
    def set_descriptions(self, descriptions): self.descriptions = descriptions
    def get_supportedFiles(self): return self.supportedFiles
    def set_supportedFiles(self, supportedFiles): self.supportedFiles = supportedFiles
    def export(self, outfile, level, namespace_='dsc:', name_='metadataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='metadataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='metadataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='metadataType'):
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('<%sdisplayName>%s</%sdisplayName>\n' % (namespace_, self.format_string(quote_xml(self.displayName).encode(ExternalEncoding), input_name='displayName'), namespace_))
        if self.rootElement is not None:
            showIndent(outfile, level)
            outfile.write('<%srootElement>%s</%srootElement>\n' % (namespace_, self.format_string(quote_xml(self.rootElement).encode(ExternalEncoding), input_name='rootElement'), namespace_))
        if self.descriptions:
            self.descriptions.export(outfile, level, namespace_, name_='descriptions', )
        if self.supportedFiles:
            self.supportedFiles.export(outfile, level, namespace_, name_='supportedFiles')
    def hasContent_(self):
        if (
            self.displayName is not None or
            self.rootElement is not None or
            self.descriptions is not None or
            self.supportedFiles is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metadataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.displayName is not None:
            showIndent(outfile, level)
            outfile.write('displayName=%s,\n' % quote_python(self.displayName).encode(ExternalEncoding))
        if self.rootElement is not None:
            showIndent(outfile, level)
            outfile.write('rootElement=%s,\n' % quote_python(self.rootElement).encode(ExternalEncoding))
        if self.descriptions is not None:
            showIndent(outfile, level)
            outfile.write('descriptions=model_.descriptionsType(\n')
            self.descriptions.exportLiteral(outfile, level, name_='descriptions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.supportedFiles is not None:
            showIndent(outfile, level)
            outfile.write('supportedFiles=model_.supportedFilesType(\n')
            self.supportedFiles.exportLiteral(outfile, level, name_='supportedFiles')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'displayName':
            displayName_ = ''
            for text__content_ in child_.childNodes:
                displayName_ += text__content_.nodeValue
            self.displayName = displayName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'rootElement':
            rootElement_ = ''
            for text__content_ in child_.childNodes:
                rootElement_ += text__content_.nodeValue
            self.rootElement = rootElement_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'descriptions':
            obj_ = descriptionsType.factory()
            obj_.build(child_)
            self.set_descriptions(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'supportedFiles':
            obj_ = supportedFilesType.factory()
            obj_.build(child_)
            self.set_supportedFiles(obj_)
# end class metadataType


class descriptionsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('desc', 'descType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, desc=None):
        if desc is None:
            self.desc = []
        else:
            self.desc = desc
    def factory(*args_, **kwargs_):
        if descriptionsType.subclass:
            return descriptionsType.subclass(*args_, **kwargs_)
        else:
            return descriptionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def add_desc(self, value): self.desc.append(value)
    def insert_desc(self, index, value): self.desc[index] = value
    def export(self, outfile, level, namespace_='dsc:', name_='descriptionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='descriptionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='descriptionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='descriptionsType'):
        for desc_ in self.desc:
            desc_.export(outfile, level, namespace_, name_='desc')
    def hasContent_(self):
        if (
            self.desc
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='descriptionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('desc=[\n')
        level += 1
        for desc_ in self.desc:
            showIndent(outfile, level)
            outfile.write('model_.descType(\n')
            desc_.exportLiteral(outfile, level, name_='descType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'desc':
            obj_ = descType.factory()
            obj_.build(child_)
            self.desc.append(obj_)

    def asDict(self):
        return dict((x.get_lang(), x.getValueOf_()) for x in self.get_desc())
# end class descriptionsType


class supportedFilesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('file', 'xsd:string', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, file=None):
        if file is None:
            self.file = []
        else:
            self.file = file
    def factory(*args_, **kwargs_):
        if supportedFilesType.subclass:
            return supportedFilesType.subclass(*args_, **kwargs_)
        else:
            return supportedFilesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def add_file(self, value): self.file.append(value)
    def insert_file(self, index, value): self.file[index] = value
    def export(self, outfile, level, namespace_='dsc:', name_='supportedFilesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='supportedFilesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='supportedFilesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='supportedFilesType'):
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('<%sfile>%s</%sfile>\n' % (namespace_, self.format_string(quote_xml(file_).encode(ExternalEncoding), input_name='file'), namespace_))
    def hasContent_(self):
        if (
            self.file
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='supportedFilesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('file=[\n')
        level += 1
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(file_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'file':
            file_ = ''
            for text__content_ in child_.childNodes:
                file_ += text__content_.nodeValue
            self.file.append(file_)
# end class supportedFilesType


class descType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('lang', 'xsd:string', 0),
        MemberSpec_('valueOf_', 'xsd:string', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=''):
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if descType.subclass:
            return descType.subclass(*args_, **kwargs_)
        else:
            return descType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='descType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='descType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='descType'):
        if self.lang is not None:
            outfile.write(' lang=%s' % (self.format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='descType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='descType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.lang is not None:
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('lang'):
            self.lang = attrs.get('lang').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class descType


class dataFieldsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('field', 'dataFieldType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, field=None):
        if field is None:
            self.field = []
        else:
            self.field = field
    def factory(*args_, **kwargs_):
        if dataFieldsType.subclass:
            return dataFieldsType.subclass(*args_, **kwargs_)
        else:
            return dataFieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field(self, index, value): self.field[index] = value
    def export(self, outfile, level, namespace_='dsc:', name_='dataFieldsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dataFieldsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='dataFieldsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='dataFieldsType'):
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field')
    def hasContent_(self):
        if (
            self.field
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataFieldsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('field=[\n')
        level += 1
        for field_ in self.field:
            showIndent(outfile, level)
            outfile.write('model_.dataFieldType(\n')
            field_.exportLiteral(outfile, level, name_='dataFieldType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'field':
            obj_ = dataFieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)

# end class dataFieldsType


class helpType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('lang', 'xsd:string', 0),
        MemberSpec_('href', 'xsd:anyURI', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, lang=None, href=None, valueOf_=''):
        self.lang = _cast(None, lang)
        self.href = _cast(None, href)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if helpType.subclass:
            return helpType.subclass(*args_, **kwargs_)
        else:
            return helpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='helpType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='helpType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='helpType'):
        if self.lang is not None:
            outfile.write(' lang=%s' % (self.format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        outfile.write(' href=%s' % (self.format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='helpType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='helpType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.lang is not None:
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.href is not None:
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('lang'):
            self.lang = attrs.get('lang').value
        if attrs.get('href'):
            self.href = attrs.get('href').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class helpType


class dataFieldType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xsd:string', 0),
        MemberSpec_('descriptions', 'descriptionsType', 0),
        MemberSpec_('help', 'helpType', 1),
        MemberSpec_('type_', 'xsd:string', 0),
        MemberSpec_('section', 'sectionType', 0),
        MemberSpec_('enumeratedType', 'enumeratedTypeType', 0),
        MemberSpec_('listType', 'listTypeType', 0),
        MemberSpec_('descriptor', 'descriptorType', 0),
        MemberSpec_('multiple', 'xsd:boolean', 0),
        MemberSpec_('default', 'xsd:string', 1),
        MemberSpec_('constraints', 'constraintsType', 0),
        MemberSpec_('required', 'xsd:boolean', 0),
        MemberSpec_('allowFileContent', 'xsd:boolean', 0),
        MemberSpec_('hidden', 'xsd:boolean', 0),
        MemberSpec_('password', 'xsd:boolean', 0),
        MemberSpec_('readonly', 'xsd:boolean', 0),
        MemberSpec_('multiline', 'xsd:boolean', 0),
        MemberSpec_('conditional', 'conditionalType', 0),
        MemberSpec_('prompt', 'descriptionsType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, name=None, descriptions=None, help=None, type_=None, section=None, enumeratedType=None, listType=None, descriptor=None, multiple=None, default=None, constraints=None, required=None, allowFileContent=None, hidden=None, password=None, readonly=None, multiline=None, conditional=None, prompt=None):
        self.name = name
        self.descriptions = descriptions
        if help is None:
            self.help = []
        else:
            self.help = help
        self.type_ = type_
        self.section = section
        self.enumeratedType = enumeratedType
        self.listType = listType
        self.descriptor = descriptor
        self.multiple = multiple
        if default is None:
            self.default = []
        else:
            self.default = default
        self.constraints = constraints
        self.required = required
        self.allowFileContent = allowFileContent
        self.hidden = hidden
        self.password = password
        self.readonly = readonly
        self.multiline = multiline
        self.conditional = conditional
        self.prompt = prompt
    def factory(*args_, **kwargs_):
        if dataFieldType.subclass:
            return dataFieldType.subclass(*args_, **kwargs_)
        else:
            return dataFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_descriptions(self): return self.descriptions
    def set_descriptions(self, descriptions): self.descriptions = descriptions
    def get_help(self): return self.help
    def set_help(self, help): self.help = help
    def add_help(self, value): self.help.append(value)
    def insert_help(self, index, value): self.help[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_section(self): return self.section
    def set_section(self, section): self.section = section
    def get_enumeratedType(self): return self.enumeratedType
    def set_enumeratedType(self, enumeratedType): self.enumeratedType = enumeratedType
    def get_listType(self): return self.listType
    def set_listType(self, listType): self.listType = listType
    def get_descriptor(self): return self.descriptor
    def set_descriptor(self, descriptor): self.descriptor = descriptor
    def get_multiple(self): return self.multiple
    def set_multiple(self, multiple): self.multiple = multiple
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def add_default(self, value): self.default.append(value)
    def insert_default(self, index, value): self.default[index] = value
    def get_constraints(self): return self.constraints
    def set_constraints(self, constraints): self.constraints = constraints
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_allowFileContent(self): return self.allowFileContent
    def set_allowFileContent(self, allowFileContent): self.allowFileContent = allowFileContent
    def get_hidden(self): return self.hidden
    def set_hidden(self, hidden): self.hidden = hidden
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_readonly(self): return self.readonly
    def set_readonly(self, readonly): self.readonly = readonly
    def get_multiline(self): return self.multiline
    def set_multiline(self, multiline): self.multiline = multiline
    def get_conditional(self): return self.conditional
    def set_conditional(self, conditional): self.conditional = conditional
    def get_prompt(self): return self.prompt
    def set_prompt(self, prompt): self.prompt = prompt
    def export(self, outfile, level, namespace_='dsc:', name_='dataFieldType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dataFieldType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='dataFieldType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='dataFieldType'):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.descriptions:
            self.descriptions.export(outfile, level, namespace_, name_='descriptions')
        for help_ in self.help:
            help_.export(outfile, level, namespace_, name_='help')
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.section:
            self.section.export(outfile, level, namespace_, name_='section')
        if self.enumeratedType:
            self.enumeratedType.export(outfile, level, namespace_, name_='enumeratedType')
        if self.listType:
            self.listType.export(outfile, level, namespace_, name_='listType')
        if self.descriptor:
            self.descriptor.export(outfile, level, namespace_, name_='descriptor')
        if self.multiple is not None:
            showIndent(outfile, level)
            outfile.write('<%smultiple>%s</%smultiple>\n' % (namespace_, self.format_boolean(str_lower(str(self.multiple)), input_name='multiple'), namespace_))
        for default_ in self.default:
            showIndent(outfile, level)
            outfile.write('<%sdefault>%s</%sdefault>\n' % (namespace_, self.format_string(quote_xml(default_).encode(ExternalEncoding), input_name='default'), namespace_))
        if self.constraints:
            self.constraints.export(outfile, level, namespace_, name_='constraints')
        if self.required is not None:
            showIndent(outfile, level)
            outfile.write('<%srequired>%s</%srequired>\n' % (namespace_, self.format_boolean(str_lower(str(self.required)), input_name='required'), namespace_))
        if self.allowFileContent is not None:
            showIndent(outfile, level)
            outfile.write('<%sallowFileContent>%s</%sallowFileContent>\n' % (namespace_, self.format_boolean(str_lower(str(self.allowFileContent)), input_name='allowFileContent'), namespace_))
        if self.hidden is not None:
            showIndent(outfile, level)
            outfile.write('<%shidden>%s</%shidden>\n' % (namespace_, self.format_boolean(str_lower(str(self.hidden)), input_name='hidden'), namespace_))
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('<%spassword>%s</%spassword>\n' % (namespace_, self.format_boolean(str_lower(str(self.password)), input_name='password'), namespace_))
        if self.readonly is not None:
            showIndent(outfile, level)
            outfile.write('<%sreadonly>%s</%sreadonly>\n' % (namespace_, self.format_boolean(str_lower(str(self.readonly)), input_name='readonly'), namespace_))
        if self.multiline is not None:
            showIndent(outfile, level)
            outfile.write('<%smultiline>%s</%smultiline>\n' % (namespace_, self.format_boolean(str_lower(str(self.multiline)), input_name='multiline'), namespace_))
        if self.conditional:
            self.conditional.export(outfile, level, namespace_, name_='conditional')
        if self.prompt:
            self.prompt.export(outfile, level, namespace_, name_='prompt')
    def hasContent_(self):
        if (
            self.name is not None or
            self.descriptions is not None or
            self.help or
            self.type_ is not None or
            self.section is not None or
            self.enumeratedType is not None or
            self.listType is not None or
            self.descriptor is not None or
            self.multiple is not None or
            self.default or
            self.constraints is not None or
            self.required is not None or
            self.allowFileContent is not None or
            self.hidden is not None or
            self.password is not None or
            self.readonly is not None or
            self.multiline is not None or
            self.conditional is not None or
            self.prompt is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataFieldType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.descriptions is not None:
            showIndent(outfile, level)
            outfile.write('descriptions=model_.descriptionsType(\n')
            self.descriptions.exportLiteral(outfile, level, name_='descriptions')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('help=[\n')
        level += 1
        for help_ in self.help:
            showIndent(outfile, level)
            outfile.write('model_.helpType(\n')
            help_.exportLiteral(outfile, level, name_='helpType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.section is not None:
            showIndent(outfile, level)
            outfile.write('section=model_.sectionType(\n')
            self.section.exportLiteral(outfile, level, name_='section')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.enumeratedType is not None:
            showIndent(outfile, level)
            outfile.write('enumeratedType=model_.enumeratedTypeType(\n')
            self.enumeratedType.exportLiteral(outfile, level, name_='enumeratedType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.listType is not None:
            showIndent(outfile, level)
            outfile.write('listType=model_.listTypeType(\n')
            self.listType.exportLiteral(outfile, level, name_='listType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.descriptor is not None:
            showIndent(outfile, level)
            outfile.write('descriptor=model_.descriptorType(\n')
            self.descriptor.exportLiteral(outfile, level, name_='descriptor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.multiple is not None:
            showIndent(outfile, level)
            outfile.write('multiple=%s,\n' % self.multiple)
        showIndent(outfile, level)
        outfile.write('default=[\n')
        level += 1
        for default_ in self.default:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(default_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.constraints is not None:
            showIndent(outfile, level)
            outfile.write('constraints=model_.constraintsType(\n')
            self.constraints.exportLiteral(outfile, level, name_='constraints')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.required is not None:
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % self.required)
        if self.allowFileContent is not None:
            showIndent(outfile, level)
            outfile.write('allowFileContent=%s,\n' % self.allowFileContent)
        if self.hidden is not None:
            showIndent(outfile, level)
            outfile.write('hidden=%s,\n' % self.hidden)
        if self.password is not None:
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % self.password)
        if self.readonly is not None:
            showIndent(outfile, level)
            outfile.write('readonly=%s,\n' % self.readonly)
        if self.multiline is not None:
            showIndent(outfile, level)
            outfile.write('multiline=%s,\n' % self.multiline)
        if self.conditional is not None:
            showIndent(outfile, level)
            outfile.write('conditional=model_.conditionalType(\n')
            self.conditional.exportLiteral(outfile, level, name_='conditional')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.prompt is not None:
            showIndent(outfile, level)
            outfile.write('prompt=model_.descriptionsType(\n')
            self.prompt.exportLiteral(outfile, level, name_='prompt')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'name':
            name_ = ''
            for text__content_ in child_.childNodes:
                name_ += text__content_.nodeValue
            self.name = name_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'descriptions':
            obj_ = descriptionsType.factory()
            obj_.build(child_)
            self.set_descriptions(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'help':
            obj_ = helpType.factory()
            obj_.build(child_)
            self.help.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            self.type_ = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'section':
            obj_ = sectionType.factory()
            obj_.build(child_)
            self.set_section(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'enumeratedType':
            obj_ = enumeratedTypeType.factory()
            obj_.build(child_)
            self.set_enumeratedType(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'listType':
            obj_ = listTypeType.factory()
            obj_.build(child_)
            self.set_listType(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'descriptor':
            obj_ = descriptorType.factory()
            obj_.build(child_)
            self.set_descriptor(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'multiple':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.multiple = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'default':
            default_ = ''
            for text__content_ in child_.childNodes:
                default_ += text__content_.nodeValue
            self.default.append(default_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'constraints':
            obj_ = constraintsType.factory()
            obj_.build(child_)
            self.set_constraints(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'required':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.required = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'allowFileContent':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.allowFileContent = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hidden':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.hidden = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'password':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.password = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'readonly':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.readonly = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'multiline':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                if sval_ in ('true', '1'):
                    ival_ = True
                elif sval_ in ('false', '0'):
                    ival_ = False
                else:
                    raise ValueError('requires boolean -- %s' % child_.toxml())
                self.multiline = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'conditional':
            obj_ = conditionalType.factory()
            obj_.build(child_)
            self.set_conditional(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'prompt':
            obj_ = descriptionsType.factory()
            obj_.build(child_)
            self.set_prompt(obj_)

    def _getType(self):
        if not self.enumeratedType or not self.enumeratedType.describedValue:
            return self.type_
        return [ x for x in self.enumeratedType.describedValue ]
    type = property(_getType)

    def sanitizeConstraints(self):
        if self.constraints is None:
            return None
        return self.constraints.sanitize()

    def sanitizeHelp(self):
        if self.help is None:
            return
        nonemptyHelp = [ x for x in self.help
            if x.href or x.lang ]
        self.help = nonemptyHelp

    def sanitizeConditionals(self):
        if self.conditional is None:
            return
        if self.conditional.fieldName and self.conditional.operator and self.conditional.value:
            return
        self.conditional = None

    def presentation(self):
        if self.constraints is None:
            return []
        return self.constraints.presentation()

    def getDefault(self):
        if not self.default:
            if self.multiple:
                return []
            return None
        from smartform.descriptor_nodes import _cast
        typ = self.type_
        if self.multiple:
            return [ _cast(x, typ) for x in self.default ]
        return _cast(self.default[0], typ)

    @property
    def helpAsDict(self):
        if self.help is None:
            return {}
        return dict((x.lang, x.href) for x in self.help
                if x.lang or x.href)

    @property
    def constraintsPresentation(self):
        if self.constraints is None:
            return []
        return self.constraints.presentation()
    # end class dataFieldType


class enumeratedTypeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('describedValue', 'describedValueType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, describedValue=None):
        if describedValue is None:
            self.describedValue = []
        else:
            self.describedValue = describedValue
    def factory(*args_, **kwargs_):
        if enumeratedTypeType.subclass:
            return enumeratedTypeType.subclass(*args_, **kwargs_)
        else:
            return enumeratedTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_describedValue(self): return self.describedValue
    def set_describedValue(self, describedValue): self.describedValue = describedValue
    def add_describedValue(self, value): self.describedValue.append(value)
    def insert_describedValue(self, index, value): self.describedValue[index] = value
    def export(self, outfile, level, namespace_='dsc:', name_='enumeratedTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='enumeratedTypeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='enumeratedTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='enumeratedTypeType'):
        for describedValue_ in self.describedValue:
            describedValue_.export(outfile, level, namespace_, name_='describedValue')
    def hasContent_(self):
        if (
            self.describedValue
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='enumeratedTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('describedValue=[\n')
        level += 1
        for describedValue_ in self.describedValue:
            showIndent(outfile, level)
            outfile.write('model_.describedValueType(\n')
            describedValue_.exportLiteral(outfile, level, name_='describedValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'describedValue':
            obj_ = describedValueType.factory()
            obj_.build(child_)
            self.describedValue.append(obj_)
# end class enumeratedTypeType


class listTypeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('descriptor', 'descriptorType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, descriptor=None):
        self.descriptor = descriptor
    def factory(*args_, **kwargs_):
        if listTypeType.subclass:
            return listTypeType.subclass(*args_, **kwargs_)
        else:
            return listTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_descriptor(self): return self.descriptor
    def set_descriptor(self, descriptor): self.descriptor = descriptor
    def export(self, outfile, level, namespace_='dsc:', name_='listTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='listTypeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='listTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='listTypeType'):
        if self.descriptor:
            self.descriptor.export(outfile, level, namespace_, name_='descriptor', )
    def hasContent_(self):
        if (
            self.descriptor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='listTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.descriptor is not None:
            showIndent(outfile, level)
            outfile.write('descriptor=model_.descriptorType(\n')
            self.descriptor.exportLiteral(outfile, level, name_='descriptor')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'descriptor':
            obj_ = descriptorType.factory()
            obj_.build(child_)
            self.set_descriptor(obj_)
# end class listTypeType


class describedValueType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('descriptions', 'descriptionsType', 0),
        MemberSpec_('key', 'xsd:string', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, descriptions=None, key=None):
        self.descriptions = descriptions
        self.key = key
    def factory(*args_, **kwargs_):
        if describedValueType.subclass:
            return describedValueType.subclass(*args_, **kwargs_)
        else:
            return describedValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_descriptions(self): return self.descriptions
    def set_descriptions(self, descriptions): self.descriptions = descriptions
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def export(self, outfile, level, namespace_='dsc:', name_='describedValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='describedValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='describedValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='describedValueType'):
        if self.descriptions:
            self.descriptions.export(outfile, level, namespace_, name_='descriptions', )
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
    def hasContent_(self):
        if (
            self.descriptions is not None or
            self.key is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='describedValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.descriptions is not None:
            showIndent(outfile, level)
            outfile.write('descriptions=model_.descriptionsType(\n')
            self.descriptions.exportLiteral(outfile, level, name_='descriptions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'descriptions':
            obj_ = descriptionsType.factory()
            obj_.build(child_)
            self.set_descriptions(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'key':
            key_ = ''
            for text__content_ in child_.childNodes:
                key_ += text__content_.nodeValue
            self.key = key_
# end class describedValueType


class constraintsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('descriptions', 'descriptionsType', 0),
        MemberSpec_('range', 'rangeType', 1),
        MemberSpec_('legalValues', 'legalValuesType', 1),
        MemberSpec_('regexp', 'regexpType', 1),
        MemberSpec_('length', 'lengthType', 1),
        MemberSpec_('uniqueKey', 'uniqueKeyType', 1),
        MemberSpec_('minLength', 'minLengthType', 0),
        MemberSpec_('maxLength', 'maxLengthType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, descriptions=None, range=None, legalValues=None, regexp=None, length=None, uniqueKey=None, minLength=None, maxLength=None):
        self.descriptions = descriptions
        if range is None:
            self.range = []
        else:
            self.range = range
        if legalValues is None:
            self.legalValues = []
        else:
            self.legalValues = legalValues
        if regexp is None:
            self.regexp = []
        else:
            self.regexp = regexp
        if length is None:
            self.length = []
        else:
            self.length = length
        if uniqueKey is None:
            self.uniqueKey = []
        else:
            self.uniqueKey = uniqueKey
        self.minLength = minLength
        self.maxLength = maxLength
    def factory(*args_, **kwargs_):
        if constraintsType.subclass:
            return constraintsType.subclass(*args_, **kwargs_)
        else:
            return constraintsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_descriptions(self): return self.descriptions
    def set_descriptions(self, descriptions): self.descriptions = descriptions
    def get_range(self): return self.range
    def set_range(self, range): self.range = range
    def add_range(self, value): self.range.append(value)
    def insert_range(self, index, value): self.range[index] = value
    def get_legalValues(self): return self.legalValues
    def set_legalValues(self, legalValues): self.legalValues = legalValues
    def add_legalValues(self, value): self.legalValues.append(value)
    def insert_legalValues(self, index, value): self.legalValues[index] = value
    def get_regexp(self): return self.regexp
    def set_regexp(self, regexp): self.regexp = regexp
    def add_regexp(self, value): self.regexp.append(value)
    def insert_regexp(self, index, value): self.regexp[index] = value
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def add_length(self, value): self.length.append(value)
    def insert_length(self, index, value): self.length[index] = value
    def get_uniqueKey(self): return self.uniqueKey
    def set_uniqueKey(self, uniqueKey): self.uniqueKey = uniqueKey
    def add_uniqueKey(self, value): self.uniqueKey.append(value)
    def insert_uniqueKey(self, index, value): self.uniqueKey[index] = value
    def get_minLength(self): return self.minLength
    def set_minLength(self, minLength): self.minLength = minLength
    def get_maxLength(self): return self.maxLength
    def set_maxLength(self, maxLength): self.maxLength = maxLength
    def export(self, outfile, level, namespace_='dsc:', name_='constraintsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='constraintsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='constraintsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='constraintsType'):
        if self.descriptions:
            self.descriptions.export(outfile, level, namespace_, name_='descriptions')
        for range_ in self.range:
            range_.export(outfile, level, namespace_, name_='range')
        for legalValues_ in self.legalValues:
            legalValues_.export(outfile, level, namespace_, name_='legalValues')
        for regexp_ in self.regexp:
            regexp_.export(outfile, level, namespace_, name_='regexp')
        for length_ in self.length:
            length_.export(outfile, level, namespace_, name_='length')
        for uniqueKey_ in self.uniqueKey:
            uniqueKey_.export(outfile, level, namespace_, name_='uniqueKey')
        if self.minLength:
            self.minLength.export(outfile, level, namespace_, name_='minLength')
        if self.maxLength:
            self.maxLength.export(outfile, level, namespace_, name_='maxLength')
    def hasContent_(self):
        if (
            self.descriptions is not None or
            self.range or
            self.legalValues or
            self.regexp or
            self.length or
            self.uniqueKey or
            self.minLength is not None or
            self.maxLength is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='constraintsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.descriptions is not None:
            showIndent(outfile, level)
            outfile.write('descriptions=model_.descriptionsType(\n')
            self.descriptions.exportLiteral(outfile, level, name_='descriptions')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('range=[\n')
        level += 1
        for range_ in self.range:
            showIndent(outfile, level)
            outfile.write('model_.rangeType(\n')
            range_.exportLiteral(outfile, level, name_='rangeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('legalValues=[\n')
        level += 1
        for legalValues_ in self.legalValues:
            showIndent(outfile, level)
            outfile.write('model_.legalValuesType(\n')
            legalValues_.exportLiteral(outfile, level, name_='legalValuesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('regexp=[\n')
        level += 1
        for regexp_ in self.regexp:
            showIndent(outfile, level)
            outfile.write('model_.regexpType(\n')
            regexp_.exportLiteral(outfile, level, name_='regexpType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('length=[\n')
        level += 1
        for length_ in self.length:
            showIndent(outfile, level)
            outfile.write('model_.lengthType(\n')
            length_.exportLiteral(outfile, level, name_='lengthType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uniqueKey=[\n')
        level += 1
        for uniqueKey_ in self.uniqueKey:
            showIndent(outfile, level)
            outfile.write('model_.uniqueKeyType(\n')
            uniqueKey_.exportLiteral(outfile, level, name_='uniqueKeyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.minLength is not None:
            showIndent(outfile, level)
            outfile.write('minLength=model_.minLengthType(\n')
            self.minLength.exportLiteral(outfile, level, name_='minLength')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maxLength is not None:
            showIndent(outfile, level)
            outfile.write('maxLength=model_.maxLengthType(\n')
            self.maxLength.exportLiteral(outfile, level, name_='maxLength')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'descriptions':
            obj_ = descriptionsType.factory()
            obj_.build(child_)
            self.set_descriptions(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'range':
            obj_ = rangeType.factory()
            obj_.build(child_)
            self.range.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'legalValues':
            obj_ = legalValuesType.factory()
            obj_.build(child_)
            self.legalValues.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'regexp':
            obj_ = regexpType.factory()
            obj_.build(child_)
            self.regexp.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'length':
            obj_ = lengthType.factory()
            obj_.build(child_)
            self.length.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'uniqueKey':
            obj_ = uniqueKeyType.factory()
            obj_.build(child_)
            self.uniqueKey.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'minLength':
            obj_ = minLengthType.factory()
            obj_.build(child_)
            self.set_minLength(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'maxLength':
            obj_ = maxLengthType.factory()
            obj_.build(child_)
            self.set_maxLength(obj_)


    _ConstraintsTypes =  [ 'range', 'legalValues', 'regexp', 'length']
    _SingleConstraintsTypes = [ 'minLength', 'maxLength', ]

    def sanitize(self):
        for constraintName in self._ConstraintsTypes:
            constraints = getattr(self, constraintName)
            nonEmptyConstraints = [ x for x in constraints
                if x.presentation() ]
            setattr(self, constraintName, nonEmptyConstraints)
        for constraintName in self._SingleConstraintsTypes:
            # Weed out empty presentations
            val = getattr(self, constraintName)
            if not val or not val.presentation():
                setattr(self, constraintName, None)

    def presentation(self):
        ret = []
        for constraintName in self._ConstraintsTypes:
            # Weed out empty presentations
            ret.extend(
                dict(y, constraintName=constraintName)
                    for y in (
                        x.presentation() for x in getattr(self, constraintName))
                    if y)
        for constraintName in self._SingleConstraintsTypes:
            # Weed out empty presentations
            val = getattr(self, constraintName)
            if val and val.presentation():
                ret.append(dict(val.presentation(), constraintName=constraintName))
        return ret

    def fromData(self, dataList):
        for dataDict in dataList:
            self._fromData(dataDict)

    def _fromData(self, data):
        constraintName = data.get('constraintName')
        if constraintName is None:
            return
        potential = [ x for x in self.member_data_items_
            if x.name == constraintName ]
        if not potential:
            return
        dataType = potential[0].get_data_type()
        cls = globals().get(dataType)
        if not cls:
            return
        v = cls()
        v.fromData(data)
        method = getattr(self, 'add_' + potential[0].name, None)
        if method is None:
            method = getattr(self, 'set_' + potential[0].name)
        method(v)
    # end class constraintsType


class rangeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('min', 'xsd:long', 0),
        MemberSpec_('max', 'xsd:long', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, min=None, max=None):
        self.min = min
        self.max = max
    def factory(*args_, **kwargs_):
        if rangeType.subclass:
            return rangeType.subclass(*args_, **kwargs_)
        else:
            return rangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def export(self, outfile, level, namespace_='dsc:', name_='rangeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='rangeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='rangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='rangeType'):
        if self.min is not None:
            showIndent(outfile, level)
            outfile.write('<%smin>%s</%smin>\n' % (namespace_, self.format_integer(self.min, input_name='min'), namespace_))
        if self.max is not None:
            showIndent(outfile, level)
            outfile.write('<%smax>%s</%smax>\n' % (namespace_, self.format_integer(self.max, input_name='max'), namespace_))
    def hasContent_(self):
        if (
            self.min is not None or
            self.max is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rangeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.min is not None:
            showIndent(outfile, level)
            outfile.write('min=%d,\n' % self.min)
        if self.max is not None:
            showIndent(outfile, level)
            outfile.write('max=%d,\n' % self.max)
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'min':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (min): %s' % exp)
                self.min = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'max':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (max): %s' % exp)
                self.max = ival_

    def presentation(self):
        ret = {}
        if self.min is not None:
            ret['min'] = self.min
        if self.max is not None:
            ret['max'] = self.max
        if not ret:
            return ret
        ret.update(constraintName = 'range')
        return ret

    def fromData(self, data):
        self.min = data.get('min')
        self.max = data.get('max')
    # end class rangeType


class legalValuesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('item', 'xsd:string', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, item=None):
        if item is None:
            self.item = []
        else:
            self.item = item
    def factory(*args_, **kwargs_):
        if legalValuesType.subclass:
            return legalValuesType.subclass(*args_, **kwargs_)
        else:
            return legalValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def add_item(self, value): self.item.append(value)
    def insert_item(self, index, value): self.item[index] = value
    def export(self, outfile, level, namespace_='dsc:', name_='legalValuesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='legalValuesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='legalValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='legalValuesType'):
        for item_ in self.item:
            showIndent(outfile, level)
            outfile.write('<%sitem>%s</%sitem>\n' % (namespace_, self.format_string(quote_xml(item_).encode(ExternalEncoding), input_name='item'), namespace_))
    def hasContent_(self):
        if (
            self.item
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='legalValuesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('item=[\n')
        level += 1
        for item_ in self.item:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(item_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'item':
            item_ = ''
            for text__content_ in child_.childNodes:
                item_ += text__content_.nodeValue
            self.item.append(item_)

    def presentation(self):
        if not self.item:
            return {}
        return dict(constraintName = 'legalValues', values = (self.item or []))

    def fromData(self, data):
        for value in data.get('values', []):
            self.add_item(value)
    # end class legalValuesType


class regexpType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xsd:string', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if regexpType.subclass:
            return regexpType.subclass(*args_, **kwargs_)
        else:
            return regexpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='regexpType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regexpType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='regexpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='regexpType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regexpType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def presentation(self):
        if not self.valueOf_:
            return {}
        return dict(constraintName = 'regexp', value = self.valueOf_)

    def fromData(self, data):
        self.setValueOf_(data.get('value'))
    # end class regexpType


class lengthType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xsd:unsignedInt', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if lengthType.subclass:
            return lengthType.subclass(*args_, **kwargs_)
        else:
            return lengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='lengthType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='lengthType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='lengthType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='lengthType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='lengthType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def presentation(self):
        if self.valueOf_ == '':
            return {}
        return dict(value = int(self.valueOf_))

    def fromData(self, data):
        self.setValueOf_(str(data.get('value')))
    # end class lengthType


class uniqueKeyType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xsd:token', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if uniqueKeyType.subclass:
            return uniqueKeyType.subclass(*args_, **kwargs_)
        else:
            return uniqueKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='uniqueKeyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='uniqueKeyType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='uniqueKeyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='uniqueKeyType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='uniqueKeyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def presentation(self):
        if not self.valueOf_:
            return {}
        return dict(value = str(self.valueOf_))

    def fromData(self, data):
        self.setValueOf_(str(data.get('value')))
    # end class uniqueKeyType


class minLengthType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xsd:nonNegativeInteger', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if minLengthType.subclass:
            return minLengthType.subclass(*args_, **kwargs_)
        else:
            return minLengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='minLengthType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='minLengthType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='minLengthType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='minLengthType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='minLengthType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def presentation(self):
        if self.valueOf_ == '':
            return {}
        return dict(value = int(self.valueOf_))

    def fromData(self, data):
        self.setValueOf_(str(data.get('value')))
    # end class minLengthType


class maxLengthType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xsd:nonNegativeInteger', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if maxLengthType.subclass:
            return maxLengthType.subclass(*args_, **kwargs_)
        else:
            return maxLengthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='maxLengthType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='maxLengthType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='maxLengthType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='maxLengthType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='maxLengthType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'

    def presentation(self):
        if self.valueOf_ == '':
            return {}
        return dict(value = int(self.valueOf_))

    def fromData(self, data):
        self.setValueOf_(str(data.get('value')))
    # end class maxLengthType


class conditionalType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('fieldName', 'xsd:string', 0),
        MemberSpec_('operator', ['operator', 'xsd:string'], 0),
        MemberSpec_('value', 'xsd:string', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, fieldName=None, operator=None, value=None):
        self.fieldName = fieldName
        self.operator = operator
        self.value = value
    def factory(*args_, **kwargs_):
        if conditionalType.subclass:
            return conditionalType.subclass(*args_, **kwargs_)
        else:
            return conditionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fieldName(self): return self.fieldName
    def set_fieldName(self, fieldName): self.fieldName = fieldName
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def validate_operator(self, value):
        # Validate type operator, a restriction on xsd:string.
        pass
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='dsc:', name_='conditionalType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='conditionalType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='conditionalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='conditionalType'):
        if self.fieldName is not None:
            showIndent(outfile, level)
            outfile.write('<%sfieldName>%s</%sfieldName>\n' % (namespace_, self.format_string(quote_xml(self.fieldName).encode(ExternalEncoding), input_name='fieldName'), namespace_))
        if self.operator is not None:
            showIndent(outfile, level)
            outfile.write('<%soperator>%s</%soperator>\n' % (namespace_, self.format_string(quote_xml(self.operator).encode(ExternalEncoding), input_name='operator'), namespace_))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.fieldName is not None or
            self.operator is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='conditionalType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fieldName is not None:
            showIndent(outfile, level)
            outfile.write('fieldName=%s,\n' % quote_python(self.fieldName).encode(ExternalEncoding))
        if self.operator is not None:
            showIndent(outfile, level)
            outfile.write('operator=%s,\n' % quote_python(self.operator).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fieldName':
            fieldName_ = ''
            for text__content_ in child_.childNodes:
                fieldName_ += text__content_.nodeValue
            self.fieldName = fieldName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'operator':
            operator_ = ''
            for text__content_ in child_.childNodes:
                operator_ += text__content_.nodeValue
            self.operator = operator_
            self.validate_operator(self.operator)    # validate type operator
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'value':
            value_ = ''
            for text__content_ in child_.childNodes:
                value_ += text__content_.nodeValue
            self.value = value_
# end class conditionalType


class operator(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', ['operator', 'xsd:string'], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if operator.subclass:
            return operator.subclass(*args_, **kwargs_)
        else:
            return operator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='dsc:', name_='operator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='operator')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='operator'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='operator'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='operator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class operator


class sectionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('key', 'xsd:string', 0),
        MemberSpec_('descriptions', 'descriptionsType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, key=None, descriptions=None):
        self.key = key
        self.descriptions = descriptions
    def factory(*args_, **kwargs_):
        if sectionType.subclass:
            return sectionType.subclass(*args_, **kwargs_)
        else:
            return sectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_descriptions(self): return self.descriptions
    def set_descriptions(self, descriptions): self.descriptions = descriptions
    def export(self, outfile, level, namespace_='dsc:', name_='sectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='dsc:', name_='sectionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='dsc:', name_='sectionType'):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.descriptions:
            self.descriptions.export(outfile, level, namespace_, name_='descriptions')
    def hasContent_(self):
        if (
            self.key is not None or
            self.descriptions is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.descriptions is not None:
            showIndent(outfile, level)
            outfile.write('descriptions=model_.descriptionsType(\n')
            self.descriptions.exportLiteral(outfile, level, name_='descriptions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'key':
            key_ = ''
            for text__content_ in child_.childNodes:
                key_ += text__content_.nodeValue
            self.key = key_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'descriptions':
            obj_ = descriptionsType.factory()
            obj_.build(child_)
            self.set_descriptions(obj_)
# end class sectionType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = descriptorType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="descriptor", 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = descriptorType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="descriptor",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = descriptorType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from supers_descriptor import *\n\n')
##     sys.stdout.write('import supers_descriptor as model_\n\n')
##     sys.stdout.write('rootObj = model_.descriptor(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_="descriptor")
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

# pyflakes=ignore-file
